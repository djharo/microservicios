package commons.usuarios.models.entity;

import java.io.Serializable;
import java.util.List;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;

@Entity
@Table(name = "USUARIOS")
public class Usuario implements Serializable {

	private static final long serialVersionUID = 4002221912401133094L;
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	
	@Column(name = "USERNAME", unique = true, length = 20) // La idea es que el nombre de usuario sea único un usuario puede tener muchos roles
	private String username;
	
	@Column(name = "PASSWORD", length = 60) //fijamos la longitud para encriptar la contraseña con un tamaño fijo en bcode.
	private String password;
	
	@Column(name = "ENABLED")
	private Boolean enabled;
	
	@Column(name = "NOMBRE")
	private String nombre;
	
	@Column(name = "APELLIDO")
	private String apellido;

	@Column(name = "EMAIL", unique = true, length = 100)
	private String email;
	
	private Integer intentos;
	
	//Carga perezosa sólo se accedera a los roles cuando se realice un getRole()
	//En este caso la relación será unidireccional. Se mostrarán cuales son los roles que están asignados a un usuario
	//No tiene sentido mostrar cuales son los usuarios que están asignados a un role
	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(name = "usuarios_roles", joinColumns = @JoinColumn(name = "usuario_id"), 
	inverseJoinColumns = @JoinColumn(name = "role_id"), 
	uniqueConstraints = {@UniqueConstraint(columnNames = { "usuario_id", "role_id" }) }) //import javax.persistence.UniqueConstraint; poner a mano no la reconoce eclipse
	private List<Role> roles;
	//Se genera una tabla con nombre usuarios_roles con dos claves foraneas de nombre usuario_id y role_id, siendo además estas dos claves únicas, es decir un usuario 
	//no puede tener el mismo rol dos veces o un role no pude tener a un usuario dos veces. pepito-grillo no se puede repetir pero pepito-piscinas si ya que el rol es diferente.
	//Si no se añadiesen las anotaciones se crearía una tabla usuario_role (con el nombre de las dos tablas usuario y role) y dos claves foraneas una
	//usuaro_id y otra roles_id (roles es el nombre del atributo roles con el que se hace la relación manytomany de usuario a role)

/* SQL GENERADO CUANDO SE LEVANTA EL SERVICIO UUSUARIOS (APARECE EN LA CONSOLA) Se pone en el properties de usuario logging.level.org.hibernate.SQL=debug
: drop table if exists roles CASCADE 
: drop table if exists usuarios CASCADE 
: drop table if exists usuarios_roles CASCADE 
: create table roles (id bigint generated by default as identity, nombre varchar(30), primary key (id))
: create table usuarios (id bigint generated by default as identity, apellido varchar(255), email varchar(20), enabled boolean, nombre varchar(255), password varchar(60), user_name varchar(20), primary key (id))
: create table usuarios_roles (usuario_id bigint not null, role_id bigint not null)
: alter table roles add constraint UK_ldv0v52e0udsh2h1rs0r0gw1n unique (nombre)
: alter table usuarios add constraint UK_kfsp0s1tflm1cwlj8idhqsad0 unique (email)
: alter table usuarios add constraint UK_r9ksbmgwvokav9vgydstfdmws unique (user_name)
: alter table usuarios_roles add constraint UKqjaspm7473pnu9y4jxhrds8r2 unique (usuario_id, role_id)
: alter table usuarios_roles add constraint FKihom0uklpkfpffipxpoyf7b74 foreign key (role_id) references roles
: alter table usuarios_roles add constraint FKqcxu02bqipxpr7cjyj9dmhwec foreign key (usuario_id) references usuarios
*/
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public Boolean getEnabled() {
		return enabled;
	}

	public void setEnabled(Boolean enabled) {
		this.enabled = enabled;
	}

	public String getNombre() {
		return nombre;
	}

	public void setNombre(String nombre) {
		this.nombre = nombre;
	}

	public String getApellido() {
		return apellido;
	}

	public void setApellido(String apellido) {
		this.apellido = apellido;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}
	
	public Integer getIntentos() {
		return intentos;
	}

	public void setIntentos(Integer intentos) {
		this.intentos = intentos;
	}

	public List<Role> getRoles() {
		return roles;
	}

	public void setRoles(List<Role> roles) {
		this.roles = roles;
	}
}
